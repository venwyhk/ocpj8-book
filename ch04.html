<!doctype html>
<html lang="zh-cn">

<head>
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Study guide for the Oracle Certified Professional, Java SE 8 Programmer Exam ">
    <title>Java 8 Programmer II Study Guide: Exam 1Z0-809</title>
    <link href="css/code.css" rel="stylesheet" type="text/css" />
    <link href="css/style.css" rel="stylesheet" type="text/css" />
    <link href="https://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">

    <script src="http://code.jquery.com/jquery-2.2.2.min.js"></script>

    <script src="js/common-sections.js"></script>
</head>

<body>

    <div class="nav"></div>

    <div class="header">
        <div class="title-container">
            <div class="chapter-title">


                <h1><i class="chapter">Chapter FOUR</i><br />
			  Interfaces<br />
<font size="2" color="blue">第四章<br />接口</font>
                </h1>

                <p><br /></p>

                <h3 style="text-align: center;"><i>Exam Objectives</i></h3>

                <p style="text-align: center;"><i>Develop code that declares, implements and/or extends interfaces and use the atOverride annotation.</i></p>



            </div>
        </div>
    </div>



    <div class="container">

        <div class="column">

            <h2>What's an interface?</h2>
<font size="2" color="blue">什么是接口？</font>

            <p>The first time you look an interface, you'll probably think that it's like a class with just methods definitions:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp;&nbsp;void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span>;<br />
	  }</code></p>

            <p>And for practical terms, you're right.</p>

            <p>An interface is a data type that just defines (abstract) methods that one class must implement.</p>

            <p>Although conceptually, it's more interesting than that, because this allows you to define what a class can do without saying how to do it. That's why it's said that an interface is a contract.</p>

            <p>Any class that implements an interface must provide an implementation for all the methods of the interface, otherwise, the class has to be marked as <code>abstract</code>.</p>

            <p>As a class is defined with the <code>class</code> keyword, an interface is defined with the <code>interface</code> keyword.</p>

            <p>If a class wants to implement an interface, it has to specify it with the <code>implements</code> keyword.</p>
            <hr />

            <h4><i>Defining an interface</i></h4>
<font size="2" color="blue">定义一个接口</font>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  <span class="hljs-keyword"><font color="#000000">&nbsp; &nbsp;&nbsp;</font>public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ID = <span class="hljs-number">0</span>;<br />
	  <span class="hljs-function"><span class="hljs-keyword"><font color="#000000">&nbsp; &nbsp;&nbsp;</font>public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span>;<br />
	  }</code></p>

            <h4><i>Implementing an interface</i></h4>
<font size="2" color="blue">继承这个接口</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp;&nbsp;public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-comment"><font color="#000000">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font>// Implementation code</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>
            <hr />

            <p>Like a class, an interface has either <code>public</code> or default accessibility:</p>
<font size="2" color="blue">和类一样，接口可以定义为<code>public</code>或默认（default）：</font>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PublicAccessInterface</span></span> {<br />
                <span class="hljs-comment"><font color="#000000">&nbsp; &nbsp;&nbsp;</font>// ...<br /></span>}</code><code class="java hljs"><span class="hljs-keyword">interface</span> <span class="hljs-class"><span class="hljs-title">DefaultAccessInterface</span></span> {<br />
	  &nbsp; &nbsp; <span class="hljs-comment">// ...<br /></span> }</code></p>

            <p>Interfaces are <code>abstract</code> by default (you don't have to specify it):</p>
<font size="2" color="blue">默认情况下接口是抽象（<code>abstract</code>）的（可以不用定义它）：</font>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PublicAccessInterface</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp;&nbsp;// This is the same as the definition above</span><br />
	  }</code></p>

            <p>This means two things:</p>
<font size="2" color="blue">这意味着：</font>

            <ul>
                <li>You can't instantiate an interface directly, it has to be implemented by a class to use it.</li>
<font size="2" color="blue">您不能实例化一个接口，必须由类来实现它。</font>

                <li>An interface cannot be marked as <code>final</code>.</li>
<font size="2" color="blue">接口不能标注为<code>final</code>。</font>
            </ul>

            <p>The methods defined in an interface are by default <b>PUBLIC</b> and <b>ABSTRACT</b>, the compiler will treat them as such even if you don't specify it.</p>
<font size="2" color="blue">在接口中定义的方法默认是<b>PUBLIC</b>和<b>ABSTRACT</b>的，即使不指定，编译器也会将其处理为这样。</font>

            <p>So even though you define an interface like this:</p>
<font size="2" color="blue">所以，即使这样定义：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span>;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp;&nbsp;void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span>;<br />
	  }</code></p>

            <p>For the compiler, the interface will look like this:</p>
<font size="2" color="blue">对编译器来说，接口也等同于下面这样：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span>;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span>;<br />
	  }</code></p>

            <p>That's the reason you must mark the method as <code>public</code> when it's implemented:</p>
<font size="2" color="blue">这也是接口实现的方法需要标注为<code>public</code>的原因：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // Implementation</span><br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="hljs-comment">// Implementation<br /></span>&nbsp; &nbsp; }<br />
	  }</code></p>

            <p>Also, that's the reason that, if one or more of the interface's methods are not implemented, you must mark the class (and the methods) as <code>abstract</code>:</p>
<font size="2" color="blue">同样的，如果类没有全部实现接口的方法，则必须将这个实现类（和方法）标记为<code>abstract</code>：</font>

            <p><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // Implementation</span><br />
	  &nbsp; &nbsp; }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp;&nbsp;public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span>;<br />
	  }</code></p>

            <p>Fields declared in an interface are by default <b>PUBLIC</b>, <b>STATIC</b>, and <b>FINAL</b>. Like methods, the compiler will treat them as such even if you don't specify it.</p>
<font size="2" color="blue">默认情况下，在接口中声明的字段是<b>PUBLIC</b>、<b>STATIC</b>和<b>FINAL</b>的。与方法一样，即使不指定，编译器也会将其处理为这样。</font>

            <p>This means that fields are <b>CONSTANTS</b> instead of <b>VARIABLES</b>:</p>
<font size="2" color="blue">也就是说，接口内的字段是常量（<b>CONSTANTS</b>）而不是变量（<b>VARIABLES</b>）：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-keyword">int</span> ID = <span class="hljs-number">0</span>; <span class="hljs-comment">// You have to assign a value at creation time</span><br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">change</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; ID = <span class="hljs-number">5</span>; <span class="hljs-comment">// This WON'T compile</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>This also means that the following declarations are all equivalent inside an interface:</p>
<font size="2" color="blue">以下几种写法在接口中是等效的：</font>

            <p><code class="java hljs"><span class="hljs-keyword">int</span> ID = <span class="hljs-number">0</span>;<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> ID = <span class="hljs-number">0</span>;<br />
	  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ID = <span class="hljs-number">0</span>;<br />
	  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ID = <span class="hljs-number">0</span>;<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ID = <span class="hljs-number">0</span>;<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ID = <span class="hljs-number">0</span>;<br />
	  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ID = <span class="hljs-number">0</span>;<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ID = <span class="hljs-number">0</span>;</code></p>

            <p>So watch out for declarations that won't compile, like these:</p>
<font size="2" color="blue">要注意一些无法编译通过的写法，比如：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; private</span> <span class="hljs-keyword">int</span> ID = <span class="hljs-number">0</span>; <span class="hljs-comment">// It cannot be private</span><br />
	  <span class="hljs-keyword">&nbsp; &nbsp; int</span> TIMEOUT; <span class="hljs-comment">// It's final, so you have to provide a value</span><br />
	  }</code></p>

            <p>There are two rules regarding inheritances and interfaces:</p>
<font size="2" color="blue">以下是两条关于接口和继承相关的规则：</font>

            <ul>
                <li>A class can implement (not extend from) any number of interfaces.</li>
<font size="2" color="blue">一个类可以实现（不是继承）任意数量的接口。</font>

                <li>An interface can extend any number of interfaces, but it cannot extend from a class.</li>
<font size="2" color="blue">一个接口可以继承任意数量的接口，但不能继承类。</font>
            </ul>

            <p>Implementing an interface is a type of inheritance. When a class implements an interface, we can use it like this to take advantage of polymorphism:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span>;<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Disk</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Monitoring Disk"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Monitoring Server"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Monitorable m = <span class="hljs-keyword">new</span> Disk();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; m.monitor();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; m = <span class="hljs-keyword">new</span> Server();&nbsp;<span class="hljs-comment">// Change implementation<br /></span>&nbsp; &nbsp; &nbsp; &nbsp; m.monitor();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>This is the output:</p>

            <p><code class="java hljs">Monitoring Disk<br />
	  Monitoring Server</code></p>

            <p>A class cannot extend from more than one class, but it can implement more than one interface. You can see the reason with an example. Consider:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Truck</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp;&nbsp;public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Accelerating truck..."</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompactCar</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp;&nbsp;public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Accelerating compact car..."</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>If you could inherit from multiple classes:</p>
<font size="2" color="blue">如果可以从多个类继承：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Truck</span>, <span class="hljs-title">CompactCar</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp;&nbsp;public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; accelerate();<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // ...</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>Which <code>accelerate()</code> method would Java choose?</p>
<font size="2" color="blue">将会执行哪一个<code>accelerate()</code>方法？</font>

            <p>This is a problem that the designers of Java decided to avoid by not allowing multiple inheritance.</p>
<font size="2" color="blue">Java中是不允许多继承的，所以不会存在这样的问题。</font>

            <p>But what if we were using interfaces?</p>
<font size="2" color="blue">但如果使用接口呢？</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Truck</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span>;<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CompactCar</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span>;<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Truck</span>, <span class="hljs-title">CompactCar</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Accelerating car"</span>); }<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // ...</span><br />
	  }</code></p>

            <p>As the interfaces don't provide an implementation, there's only one (<code>Car</code>'s implementation) so there's no conflict and we avoid the problem altogether!</p>
<font size="2" color="blue">由于这个接口只有唯一的实现（<code>Car</code>），所以也不会存在这样的问题。</font>

            <p>And if the methods have the same name but different parameters:</p>
<font size="2" color="blue">如果方法的名称相同，但参数不同：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Truck</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span>;<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CompactCar</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> speed)</span></span>;<br />
	  }</code></p>

            <p>They're considered two different methods because the method's signature is different, so the implementing class has to implement both versions of the methods:</p>
<font size="2" color="blue">这样会被认为是两个不同的方法，因为标识不同，所以必须分别实现两个方法：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Truck</span>, <span class="hljs-title">CompactCar</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // implementation</span><br />
	  &nbsp; &nbsp; }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> speed)</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // implementation</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>However, when the methods only differ in their return type, since the return type is not considered in the method's signature, the Java compiler will generate an error:</p>
<font size="2" color="blue">然而，如果两个方法仅有返回值不同，返回值不属于方法的表示，所以这将无法通过编译：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Truck</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span>;<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CompactCar</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; int</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span>;<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Truck</span>, <span class="hljs-title">CompactCar</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp; // Java will complain about duplicate methods</span><br />
	  <span class="hljs-comment">&nbsp; &nbsp; // and incompatible return types</span><br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // implementation</span><br />
	  &nbsp; &nbsp; }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // implementation</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>Optionally, to make things clearer, we can use the <code>@Override</code> annotation.</p>
<font size="2" color="blue">另外，为了使其更加清晰，我们可以使用<code>@Override</code>标注。</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CompactCar</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; int</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span>;<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CompactCar</span></span> {<br />
	  <span class="hljs-annotation">&nbsp; &nbsp; @Override<br /></span><span class="hljs-function"><span class="hljs-keyword"><font color="#000000">&nbsp; &nbsp;&nbsp;</font>public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="hljs-comment">// implementation</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p><code>@Override</code> indicates that a method overrides a method declaration in a supertype, either in an interface or a parent class.</p>

            <p>If the annotated method doesn't override or implement the method correctly, the compiler will generate an error.</p>

            <p>This is the only function of the annotation. It's useful in cases like when there's a not-so-obvious error caused by a typo:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CompactCar</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; int</span> <span class="hljs-title">accelerate</span><span class="hljs-params">()</span></span>;<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CompactCar</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp; // Compiler will mark an error about method</span><br />
	  <span class="hljs-comment">&nbsp; &nbsp; // "acelerate" not overriding or implementing something</span><br />
	  <span class="hljs-annotation">&nbsp; &nbsp; @Override</span><br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">acelerate</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // implementation</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>Finally, an interface can only extend other interfaces.</p>
<font size="2" color="blue">最后要说的是，接口只能扩展其它的接口。</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Monitorable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span>;<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Pluggable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">plug</span><span class="hljs-params">()</span></span>;<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Resource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Monitorable</span>, <span class="hljs-title">Pluggable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span></span>;<br />
	  }</code></p>

            <p>A non-abstract class implementing <code>Resource</code>, must implement all the methods of the three interfaces:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Disk</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Resource</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // implementation</span><br />
	  &nbsp; &nbsp; }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">plug</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // implementation</span><br />
	  &nbsp; &nbsp; }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // implementation</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <h2>What's new in Java 8?</h2>
<font size="2" color="blue">Java8有哪些新特性呢？</font>

            <p>Assume we have an interface like this:</p>
<font size="2" color="blue">假设由这样一个接口：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span>;<br />
	  }</code></p>

            <p>And an implementation:</p>
<font size="2" color="blue">以及它的实现：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println("Processing in sequence");<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>We know that when a class implements an interface, unless the class is marked as <code>abstract</code>, it has to implement <b>ALL</b> the methods of that interface.</p>
<font size="2" color="blue">如前所述，当类实现接口时，除非该类被标记为<code>abstract</code>，否则它必须实现该接口的<b>所有</b>方法。</font>

            <p>So if we add another method to <code>Processable</code>, for example:</p>
<font size="2" color="blue">所以如果我们在<code>Processable</code>接口中又添加了一个方法，例如：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span>;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span>;<br />
	  }</code></p>

            <p>We have to update the class to avoid a compilation error:</p>
<font size="2" color="blue">为了避免编译错误，我们必须要修改实现类：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Processing in sequence"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Processing in parallel"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>That was easy. But think about the following:</p>
<font size="2" color="blue">这看上去很容易理解，但我们需要思考下面几个问题：</font>

            <ul>
                <li>What if we have hundreds of classes implementing <code>Processable</code>?</li>
<font size="2" color="blue">如果我们有成百上千个<code>Processable</code>的实现类呢？</font>

                <li>What if we can't update or don't have access to the code for some reason?</li>
<font size="2" color="blue">如果我们无法修改，或因为某些原因不能访问到这些代码的时候，该怎么办呢？</font>

                <li>What if the new method is not needed or doesn't make sense for some implementations?</li>
<font size="2" color="blue">如果新的方法不重要，或者没有意义，又该怎样做？</font>
            </ul>

            <p>These are real problems, sometimes not easy to solve.</p>
<font size="2" color="blue">以上这些都是很实际的问题，而且还很难完美解决。</font>

            <p>However, Java 8 gives us <i>default</i> methods. We don't have to provide implementations for them because they are non-abstract methods.</p>
<font size="2" color="blue">然而，Java8新提供了默认（<i>default</i>）方法。因为这不是抽象方法，所以我们可以不用去实现它。</font>

            <p>In other words, interfaces now allow methods with a <b>BODY</b>. And this is not as simple as it sounds.</p>
<font size="2" color="blue">也就是说，接口<b>本体</b>现在可以有方法了。但这还没这么简单。</font>

            <h2>Default methods</h2>
<font size="2" color="blue">默认方法</font>

            <p>The main reason for adding <i>default</i> methods to interfaces was to support <i>interface evolution</i>, to add new functionality to interfaces and at the same time, ensuring compatibility with the code written for older versions.</p>

            <p>There are two other side effects worth mentioning:</p>
<font size="2" color="blue">以下两点需要特别注意：</font>

            <ul>
                <li><b>We can now design <i>optional</i> methods</b>. We can have methods with limited or default functionality so the classes implementing the interfaces can decide if they keep that functionality or provide another one.</li>

                <li><b>We can have <i>utility</i> methods directly on the interface</b>. Methods that get or create resources, for example, made just for convenience and possibly implemented in terms of non-default methods of the interface.</li>
            </ul>

            <p>However, now that interfaces can provide behavior, the difference with abstract classes is not very clear in some cases. There are still two significant differences:</p>

            <ul>
                <li>A class can only extend from <b>ONE</b> abstract class, but it can implement <b>MULTIPLE</b> interfaces.</li>

                <li>An abstract class can have a state through <b>INSTANCE</b> variables (fields). An interface <b>CAN'T</b>.</li>
            </ul>

            <p>Default methods come with many rules, especially regarding inheritance. But let's start with their syntax.</p>
            <hr />

            <h4><i>Defining a default method</i></h4>
<font size="2" color="blue">定义一个默认方法</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span>;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="hljs-comment">/** Default implementation goes here */</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p><i>An interface can have any number of abstract and default methods.</i></p>

            <p><i>All methods with the keyword default must have a body.</i></p>

            <p><i>Default methods are public implicitly, just as any other method of an interface.</i></p>
            <hr />

            <p>By making <code>processInParallel()</code> a <i>default</i> method, the implementing class gets it automatically. Here's the complete example:</p>
<font size="2" color="blue"><code>processInParallel()</code>是默认（<i>default</i>）方法，实现类将会自动适配。下面是完整的例子：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span>;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Processing in parallel"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Processing in sequence"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Task t = <span class="hljs-keyword">new</span> Task();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; t.processInSequence();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; t.processInParallel(); <span class="hljs-comment">// It compiles just fine</span>&nbsp;<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>This is the most simple scenario, where the implementing class inherits the <i>default</i> method.</p>
<font size="2" color="blue">这是最基本的使用场景，实现类继承了接口的默认（<i>default</i>）方法。</font>

            <p>Before presenting more complex scenarios, let's see what the restrictions are when using <i>default</i> methods.</p>
<font size="2" color="blue">在演示更复杂的使用场景前，让我们先来看看使用默认（<i>default</i>）方法时有哪些限制。</font>

            <p><b>Default methods cannot be final.</b><br /> If a method is <code>final</code>, it cannot be overridden by the implementing classes, which doesn't favor the primary objective of <i>default</i> methods.</p>
<font size="2" color="blue"><b>默认方法不是final的。</b><br />如果方法标注是<code>final</code>的，那么它将不能被实现类重写，这与使用默认（<i>default</i>）方法的主要目标背道而驰。</font>

            <p><b>Default methods cannot be synchronized.</b><br /> This was a deliberate decision by the designers of the language. If a method is made synchronized in the interface, it would mean that all the implementing classes would inherit this behavior. But this decision should belong to the implementation; the interface has no reasonable basis for assuming what the synchronization policy should be.</p>
<font size="2" color="blue"><b>默认方法不是同步（synchronized）的。</b><br />这是Java语言设计者深思熟虑后的决定。如果一个方法在接口中进行同步，则意味着所有实现类都将是同步的。但这应该由实现类来决定，而不应该由接口来决定同步策略是什么。</font>

            <p><b>Default methods are always public.</b><br /> Like other methods of an interface. Contrast this with an abstract class, where you can choose the visibility of the method.</p>
<font size="2" color="blue"><b>默认方法始终是public的。</b><br />这跟接口的其他方法一样。这与抽象类不同，抽象类可以自由选择方法的可见性。</font>

            <p><b>You cannot have default methods for the <code>Object</code>'s class methods.</b><br /> An interface cannot provide default implementations for:</p>
<font size="2" color="blue"><b>不允许为对象（<code>Object</code>）的类方法设置默认方法。</b><br />接口不能将以下几个方法作为默认方法：</font>

            <p><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span><br />
	  <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span><br />
	  String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span></code></p>

            <p>If an interface has methods with those signatures, the compiler will throw an error. The reason is that those methods are all about the object's state. Since interfaces do not have a state, these methods should be in the implementing classes.</p>
<font size="2" color="blue">如果接口的默认方法有带有以上这些方法的标识，那么编译器就会抛错。因为这些方法都是跟对象状态有关的。而接口是没有状态的，所以这些方法不应该出现在接口中。</font>

            <p>And now, to the more complex scenarios.</p>
<font size="2" color="blue">接下来来看看更复杂的场景。</font>

            <h2>Class overrides default method</h2>
<font size="2" color="blue">在实现类中重写默认方法</font>

            <p>Classes always <b>WIN</b> over interfaces. If a class overrides a default method, the class method will be the one used. For example:</p>
<font size="2" color="blue">类方法的优先级<b>大于</b>接口方法。如果某个实现类重写了接口的默认方法，将会优先选择实现类的方法。例如:</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span>;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Default parallel"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Processable</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Processing in sequence"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Class parallel"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Task t = <span class="hljs-keyword">new</span> Task();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; t. processInParallel();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>The output would be:</p>
<font size="2" color="blue">将输出：</font>

            <p><code class="java hljs">Class parallel</code></p>

            <p>This is true even if the class redefines the default method as <code>abstract</code>:</p>
<font size="2" color="blue">就算实现类为抽象（<code>abstract</code>）的，也一样：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span>;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Default parallel"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-comment">// Class Task has to be abstract<br /></span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Processable</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Processing in sequence"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span>;<br />
	  }</code></p>

            <p>If for some reason, you need to call the default implementation of the method, you can do it with the name of the interface followed by the keyword <code>super</code>:</p>
<font size="2" color="blue">假如出于某种原因，您需要调用默认方法，可以用接口的名称加关键字<code>super</code>，如下：</font>

            <p><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; Processable.<span class="hljs-keyword">super</span>.processInParallel();<br />
	  }</code></p>

            <p>This only works with default methods. Calling a non-default method in this way will result in a compilation error. Also, <code>super</code> must be used with a direct super interface of the class.</p>
<font size="2" color="blue">这种调用方式只适用于默认方法。以这种方式调用非默认方法将会编译错误。而且，<code>super</code>必须与该类实现的那个接口一起使用。</font>

            <p>Another scenario related to this rule is when an inherited instance method from a class overrides a default interface method:</p>
<font size="2" color="blue">与此规则相关的另一个场景是类继承的实例，重写了接口的默认方法，如下：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Default parallel"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Process</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Class parallel"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span><br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; extends</span> <span class="hljs-title">Process</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Processable</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Task t = <span class="hljs-keyword">new</span> Task();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; t.processInParallel();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>The output is:</p>
<font size="2" color="blue">将输出：</font>

            <p><code class="java hljs">Class parallel</code></p>

            <p>The method <code>processInParallel()</code> returns the string <code>"Class parallel"</code> since the class <code>Task</code> inherits the method <code>processInParallel()</code> from the class <code>Process</code>, which overrides the default method of the same name in the interface <code>Processable</code>.</p>

            <h2>Interface inheritance with default methods</h2>
<font size="2" color="blue">接口默认方法被继承</font>

            <p>More specific interfaces (or classes) always <b>WIN</b> over less specific ones. The default methods of the shallower interfaces in an inheritance hierarchy will be used. For example:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span>;<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Processable parallel"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Parallelizable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Processable</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Parallelizable parallel"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parallelizable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Processing in sequence"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Task t = <span class="hljs-keyword">new</span> Task();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; t.processInParallel();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>The output would be:</p>

            <p><code class="java hljs">Parallelizable parallel</code></p>

            <p>The interface <code>Parallelizable</code> inherits the default method <code>processInParallel()</code>, but since it redefines the method when <code>Task</code> implements it, its implementation is the one called.</p>

            <p>If <code>Parallelizable</code> defined <code>processInParallel()</code> as <code>abstract</code>:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Parallelizable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span>;<br />
	  }</code></p>

            <p>Then <code>Task</code> would have to implement the method (to not become an <code>abstract</code> class):</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parallelizable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Processing in sequence"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Task parallelizable"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Task t = <span class="hljs-keyword">new</span> Task();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; t.processInParallel();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>The output would be:</p>

            <p><code class="java hljs">Task parallelizable</code></p>

            <h2>Multiple interface inheritance with default methods</h2>
<font size="2" color="blue">继承多个接口的默认方法</font>

            <p>Classes can implement multiple interfaces. What happens when two interfaces have the same default method? Which one does the implementing class will choose? For example:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span>;<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Processable parallel"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Parallelizable</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Parallelizable parallel"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span><br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; implements</span> <span class="hljs-title">Processable</span>, <span class="hljs-title">Parallelizable</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Processing in sequence"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Task t = <span class="hljs-keyword">new</span> Task();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; t.processInParallel();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>It turns out that the result is a compiler error:</p>
<font size="2" color="blue">将无法通过编译：</font>

            <p><code class="hljs">Duplicate default methods named processInParallel with the parameters () and () are inherited from the types Parallelizable and Processable.</code></p>

            <p>The compiler doesn't know which to choose, so it generates an error. In this case, <code>Task</code> has to provide an implementation (honoring the previous rule of <i>more specific interfaces (or classes) always wins over less specific ones)</i> to override the interface <code>default</code> methods and solve the issue:</p>

            <p><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span><br />
  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; implements</span> <span class="hljs-title">Processable</span>, <span class="hljs-title">Parallelizable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInSequence</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Processing in sequence"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Task parallelizable"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Task t = <span class="hljs-keyword">new</span> Task();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; t.processInParallel();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>And now, the output would be:</p>

            <p><code class="java hljs">Task parallelizable</code></p>

            <p>Of course, we can always call a default implementation with:</p>
<font size="2" color="blue">当然，我们也可以调用接口的默认方法：</font>

            <p><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; Processable.<span class="hljs-keyword">super</span>.processInParallel();<br />
	  }</code></p>
            <hr />

            <h4>Defining a static method</h4>
<font size="2" color="blue">定义一个静态方法</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; /** Implementation goes here */</span><br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p><i>Static methods in interfaces are defined just like static methods in classes, with the keyword <code>static</code>.</i></p>

            <p><i>Static methods are <code>public</code> implicitly, just as any other method of an interface.</i></p>

            <p><i>An interface can have any number of static methods.</i></p>
            <hr />

            <h2>Static methods</h2>
<font size="2" color="blue">静态方法</font>

            <p>Whenever we refer to something static, we mean something that belongs to a class, not to a particular instance or object of that class. Static methods on interfaces follow the same concept; they belong to the interface where they are declared.</p>

            <p>They were added to assist default methods and to better organize helper methods, because generally, helper or utility methods are defined in another class (like <code>java.utils.Collections</code>), instead of where they naturally belong.</p>

            <p>For example, the <code>java.util.Comparator</code> interface defines the static method:</p>

            <p><code class="java hljs"><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Comparator&lt;T&gt; <span class="hljs-title">comparingInt</span><span class="hljs-params">(ToIntFunction&lt;? <span class="hljs-keyword">super</span> T&gt; keyExtractor)</span></span></code></p>

            <p>Used by the default method:</p>

            <p><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">default</span> Comparator&lt;T&gt; <span class="hljs-title">thenComparingInt</span><span class="hljs-params">(ToIntFunction&lt;? <span class="hljs-keyword">super</span> T&gt; keyExtractor)</span></span></code></p>

            <p>Interface <code>static</code> methods are not inherited, you must prefix the method with the interface name:</p>
<font size="2" color="blue">接口的静态（<code>static</code>）方法是不能被继承的，需加上接口名前缀：</font>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Parallelizable</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(String s)</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(s);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInParallel</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; log(<span class="hljs-string">"Parallelizable parallel"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parallelizable</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Task t = <span class="hljs-keyword">new</span> Task();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; t.processInParallel();<br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // t.log("The end"); Doesn't compile</span><br />
	  <span class="hljs-comment">&nbsp; &nbsp; &nbsp; &nbsp; // Task.log("The end"); Doesn't compile either<br /></span>&nbsp; &nbsp; &nbsp; &nbsp; Parallelizable.log(<span class="hljs-string">"The end"</span>); <span class="hljs-comment">// Compiles!<br /></span>&nbsp; &nbsp; }<br />
	  }</code></p>

            <p>The output is:</p>
<font size="2" color="blue">将输出：</font>

            <p><code class="java hljs">Parallelizable parallel The end</code></p>



            <h2>Key Points</h2>

            <ul>
                <li>An interface is a data type that just defines (<code>abstract</code>) methods that one class must implement.</li>

                <li>An interface is defined with the <code>interface</code> keyword. If a class wants to implement an interface, it has to specify it with the <code>implements</code> keyword.</li>

                <li>An interface has either <code>public</code> or <code>default</code> accessibility and is abstract by default.</li>

                <li>The methods defined in an interface are by default <code>public</code> and <code>abstract</code>. The compiler will treat them as such even if you don't specify it.</li>

                <li>Fields declared in an interface are by default <code>public</code>, <code>static</code>, and <code>final</code>. Like methods, the compiler will treat them as such even if you don't specify it.</li>

                <li>This means that fields are constants instead of variables.</li>

                <li>A class can implement (not extend from) any number of interfaces.</li>

                <li>An interface can extend any number of interfaces, but it cannot extend from a class.</li>

                <li><code>@Override</code> indicates that a method overrides a method declaration in a supertype, either in an interface or a parent class.</li>

                <li>If the annotated method doesn't override or implement the method correctly, the compiler will generate an error.</li>

                <li>Java 8 introduced default methods in interfaces to support <i>interface evolution</i>, adding new functionality to interfaces and at the same time, ensuring compatibility with the code written for older versions.</li>

                <li>Default methods are methods marked with the <code>default</code> keyword, and they must have a body. The implemented classes can use and optionally redefine these methods.</li>

                <li>Default methods are always <code>public</code>, but not <code>static</code>.</li>

                <li>Default methods cannot be <code>synchronized</code> or <code>final</code>.</li>

                <li>You cannot define default methods with the same signature as the <code>Object</code> class methods: <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>;<br />
		<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br />
		<span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;</code></li>

                <li>In an inheritance hierarchy, the most specific method is the one called.</li>

                <li>One case is if a class redefines a default method, the class method is the one that gets called.</li>

                <li>Another case is if an interface redefines a default method inherited from a super interface, the method of the subinterfaces is the one called.</li>

                <li>If a class implements two different interfaces with the same default method (same method signature), the class must redefine the method. Otherwise, a compiler error is generated.</li>

                <li>If you want to call the default method of the interface from the implementing class (or extending interface), do it this way: <code class="java hljs">NameOfTheInteface.<span class="hljs-keyword">super</span>.defaultMethod();</code></li>

                <li>Java 8 also introduced <code>static</code> methods in interfaces so they can contain helper or utility methods.</li>

                <li>Static methods are marked with the <code>static</code> keyword, and they also must have a body.</li>

                <li>Static methods in interfaces have the same meaning that <code>static</code> methods in classes, so they are not inherited.</li>

                <li>If you want to call a default method from a particular interface, do it this way: <code class="java hljs">NameOfTheInteface.staticMethod();</code></li>
            </ul>



            <h2>Self Test</h2>

            <p>1. Given:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">aMethod</span><span class="hljs-params">()</span></span> {<br />
	  <span class="hljs-keyword">&nbsp; &nbsp; &nbsp; &nbsp; return</span> <span class="hljs-number">0</span>;<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">aMethod</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Test t = <span class="hljs-keyword">new</span> Test();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(t.aMethod());<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>What is the result?<br /> A. <code>0</code><br /> B. <code>1</code><br /> C. Compilation fails<br /> D. An exception occurs at runtime</p>



            <p>2. Given:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"B test"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Question_4_2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">B</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Q test"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Question_4_2 q = <span class="hljs-keyword">new</span> Question_4_2();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; q.test();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>What is the result?<br /> A. <code>B test</code><br /> B. <code>Q test</code><br /> C. Compilation fails<br /> D. An exception occurs at runtime</p>



            <p>3. Given:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">C</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(C obj)</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="hljs-keyword">return</span> obj == <span class="hljs-keyword">this</span>;<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Question_4_3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">C</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Question_4_3 q = <span class="hljs-keyword">new</span> Question_4_3();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(q.equals(q));<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>What is the result?<br /> A. <code>true</code><br /> B. <code>false</code><br /> C. Compilation fails<br /> D. An exception occurs at runtime</p>



            <p>4. Given:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">D</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"D"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">D</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"E"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Question_4_4</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">E</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; E.<span class="hljs-keyword">super</span>.print();<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Question_4_4 q = <span class="hljs-keyword">new</span> Question_4_4();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; q.print();<br />
	  &nbsp; &nbsp;}<br />
	  }</code></p>

            <p>What is the result?<br /> A. <code>D</code><br /> B. <code>E</code><br /> C. <code>D</code> and then <code>E</code><br /> D. Compilation fails<br /> E. An exception occurs at runtime</p>



            <p>5. Given:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">F</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"F test"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Question_4_5</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">F</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Q test"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; F q = <span class="hljs-keyword">new</span> Question_4_5();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; q.test();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>What is the result?<br /> A. <code>F test</code><br /> B. <code>Q test</code><br /> C. Compilation fails<br /> D. An exception occurs at runtime</p>



            <p>6. Given:</p>

            <p><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">G</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doIt</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"G - Do It"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  }<br />
	  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">H</span></span> {<br />
	  <span class="hljs-function"><span class="hljs-keyword">&nbsp; &nbsp; void</span> <span class="hljs-title">doIt</span><span class="hljs-params">()</span></span>;<br />
	  }<br />
	  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Question_4_6</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">G</span>, <span class="hljs-title">H</span></span> {<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doIt</span><span class="hljs-params">()</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(<span class="hljs-string">"Do It"</span>);<br />
	  &nbsp; &nbsp; }<br />
	  &nbsp; &nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span> {<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; Question_4_6 q = <span class="hljs-keyword">new</span> Question_4_6();<br />
	  &nbsp; &nbsp; &nbsp; &nbsp; q.doIt();<br />
	  &nbsp; &nbsp; }<br />
	  }</code></p>

            <p>What is the result?<br /> A. <code>G - Do It</code><br /> B. <code>Do It</code><br /> C. Compilation fails<br /> D. An exception occurs at runtime</p>




            <div class="answers">
                <a href="ch04a.html" target="_blank">Open answers page</a>
            </div>

            <div class="book-info"></div>

            <div class="linkbox">
                <div class="previous">
                    <a href="ch03.html">03. Inner Classes</a>
                </div>
                <div class="next">
                    <a href="ch05.html">05. Enumerations</a>
                </div>
                <div style="clear:both;"></div>
            </div>

        </div>
    </div>



</body>

</html>
